!function(t, n) {
  "object" == typeof exports && "undefined" != typeof module ? n(exports) : "function" == typeof define && define.amd ? define([ "exports" ], n) : n(t.ActionCable = {});
}(this, function(t) {
  "use strict";
  var n = "undefined" != typeof window ? window : global, e = {
    logger: n.console,
    WebSocket: n.WebSocket
  }, o = {
    log: function() {
      if (this.enabled) {
        for (var t, n = arguments.length, o = Array(n), i = 0; i < n; i++) o[i] = arguments[i];
        o.push(Date.now()), (t = e.logger).log.apply(t, [ "[ActionCable]" ].concat(o));
      }
    }
  }, i = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
    return typeof t;
  } : function(t) {
    return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, r = function(t, n) {
    if (!(t instanceof n)) throw new TypeError("Cannot call a class as a function");
  }, s = function() {
    function t(t, n) {
      for (var e = 0; e < n.length; e++) {
        var o = n[e];
        o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), 
        Object.defineProperty(t, o.key, o);
      }
    }
    return function(n, e, o) {
      return e && t(n.prototype, e), o && t(n, o), n;
    };
  }(), c = function() {
    return new Date().getTime();
  }, u = function(t) {
    return (c() - t) / 1e3;
  }, l = function() {
    function t(n) {
      r(this, t), this.visibilityDidChange = this.visibilityDidChange.bind(this), this.connection = n, 
      this.reconnectAttempts = 0;
    }
    return t.prototype.start = function() {
      this.isRunning() || (this.startedAt = c(), delete this.stoppedAt, this.startPolling(), 
      addEventListener("visibilitychange", this.visibilityDidChange), o.log("ConnectionMonitor started. pollInterval = " + this.getPollInterval() + " ms"));
    }, t.prototype.stop = function() {
      this.isRunning() && (this.stoppedAt = c(), this.stopPolling(), removeEventListener("visibilitychange", this.visibilityDidChange), 
      o.log("ConnectionMonitor stopped"));
    }, t.prototype.isRunning = function() {
      return this.startedAt && !this.stoppedAt;
    }, t.prototype.recordPing = function() {
      this.pingedAt = c();
    }, t.prototype.recordConnect = function() {
      this.reconnectAttempts = 0, this.recordPing(), delete this.disconnectedAt, o.log("ConnectionMonitor recorded connect");
    }, t.prototype.recordDisconnect = function() {
      this.disconnectedAt = c(), o.log("ConnectionMonitor recorded disconnect");
    }, t.prototype.startPolling = function() {
      this.stopPolling(), this.poll();
    }, t.prototype.stopPolling = function() {
      clearTimeout(this.pollTimeout);
    }, t.prototype.poll = function() {
      var t = this;
      this.pollTimeout = setTimeout(function() {
        t.reconnectIfStale(), t.poll();
      }, this.getPollInterval());
    }, t.prototype.getPollInterval = function() {
      var t = this.constructor.pollInterval, n = t.min, e = t.max, o = t.multiplier * Math.log(this.reconnectAttempts + 1);
      return Math.round(1e3 * function(t, n, e) {
        return Math.max(n, Math.min(e, t));
      }(o, n, e));
    }, t.prototype.reconnectIfStale = function() {
      this.connectionIsStale() && (o.log("ConnectionMonitor detected stale connection. reconnectAttempts = " + this.reconnectAttempts + ", pollInterval = " + this.getPollInterval() + " ms, time disconnected = " + u(this.disconnectedAt) + " s, stale threshold = " + this.constructor.staleThreshold + " s"), 
      this.reconnectAttempts++, this.disconnectedRecently() ? o.log("ConnectionMonitor skipping reopening recent disconnect") : (o.log("ConnectionMonitor reopening"), 
      this.connection.reopen()));
    }, t.prototype.connectionIsStale = function() {
      return u(this.pingedAt ? this.pingedAt : this.startedAt) > this.constructor.staleThreshold;
    }, t.prototype.disconnectedRecently = function() {
      return this.disconnectedAt && u(this.disconnectedAt) < this.constructor.staleThreshold;
    }, t.prototype.visibilityDidChange = function() {
      var t = this;
      "visible" === document.visibilityState && setTimeout(function() {
        !t.connectionIsStale() && t.connection.isOpen() || (o.log("ConnectionMonitor reopening stale connection on visibilitychange. visbilityState = " + document.visibilityState), 
        t.connection.reopen());
      }, 200);
    }, t;
  }();
  l.pollInterval = {
    min: 3,
    max: 30,
    multiplier: 5
  }, l.staleThreshold = 6;
  var p = {
    message_types: {
      welcome: "welcome",
      disconnect: "disconnect",
      ping: "ping",
      confirmation: "confirm_subscription",
      rejection: "reject_subscription"
    },
    disconnect_reasons: {
      unauthorized: "unauthorized",
      invalid_request: "invalid_request",
      server_restart: "server_restart"
    },
    default_mount_path: "/cable",
    protocols: [ "actioncable-v1-json", "actioncable-unsupported" ]
  }, a = p.message_types, h = p.protocols, f = h.slice(0, h.length - 1), d = [].indexOf, y = function() {
    function t(n) {
      r(this, t), this.open = this.open.bind(this), this.consumer = n, this.subscriptions = this.consumer.subscriptions, 
      this.monitor = new l(this), this.disconnected = !0;
    }
    return t.prototype.send = function(t) {
      return !!this.isOpen() && (this.webSocket.send(JSON.stringify(t)), !0);
    }, t.prototype.open = function() {
      return this.isActive() ? (o.log("Attempted to open WebSocket, but existing socket is " + this.getState()), 
      !1) : (o.log("Opening WebSocket, current state is " + this.getState() + ", subprotocols: " + h), 
      this.webSocket && this.uninstallEventHandlers(), this.webSocket = new e.WebSocket(this.consumer.url, [].concat(h, [ this.consumer.jwt_token ])), 
      this.installEventHandlers(), this.monitor.start(), !0);
    }, t.prototype.close = function() {
      if ((arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {
        allowReconnect: !0
      }).allowReconnect || this.monitor.stop(), this.isActive()) return this.webSocket.close();
    }, t.prototype.reopen = function() {
      if (o.log("Reopening WebSocket, current state is " + this.getState()), !this.isActive()) return this.open();
      try {
        return this.close();
      } catch (t) {
        o.log("Failed to reopen WebSocket", t);
      } finally {
        o.log("Reopening WebSocket in " + this.constructor.reopenDelay + "ms"), setTimeout(this.open, this.constructor.reopenDelay);
      }
    }, t.prototype.getProtocol = function() {
      if (this.webSocket) return this.webSocket.protocol;
    }, t.prototype.isOpen = function() {
      return this.isState("open");
    }, t.prototype.isActive = function() {
      return this.isState("open", "connecting");
    }, t.prototype.isProtocolSupported = function() {
      return d.call(f, this.getProtocol()) >= 0;
    }, t.prototype.isState = function() {
      for (var t = arguments.length, n = Array(t), e = 0; e < t; e++) n[e] = arguments[e];
      return d.call(n, this.getState()) >= 0;
    }, t.prototype.getState = function() {
      if (this.webSocket) for (var t in e.WebSocket) if (e.WebSocket[t] === this.webSocket.readyState) return t.toLowerCase();
      return null;
    }, t.prototype.installEventHandlers = function() {
      for (var t in this.events) {
        var n = this.events[t].bind(this);
        this.webSocket["on" + t] = n;
      }
    }, t.prototype.uninstallEventHandlers = function() {
      for (var t in this.events) this.webSocket["on" + t] = function() {};
    }, t;
  }();
  y.reopenDelay = 500, y.prototype.events = {
    message: function(t) {
      if (this.isProtocolSupported()) {
        var n = JSON.parse(t.data), e = n.identifier, i = n.message, r = n.reason, s = n.reconnect;
        switch (n.type) {
         case a.welcome:
          return this.monitor.recordConnect(), this.subscriptions.reload();

         case a.disconnect:
          return o.log("Disconnecting. Reason: " + r), r === p.disconnect_reasons.unauthorized && this.subscriptions.notifyAll("unauthorized"), 
          this.close({
            allowReconnect: s
          });

         case a.ping:
          return this.monitor.recordPing();

         case a.confirmation:
          return this.subscriptions.notify(e, "connected");

         case a.rejection:
          return this.subscriptions.reject(e);

         default:
          return this.subscriptions.notify(e, "received", i);
        }
      }
    },
    open: function() {
      if (o.log("WebSocket onopen event, using '" + this.getProtocol() + "' subprotocol"), 
      this.disconnected = !1, !this.isProtocolSupported()) return o.log("Protocol is unsupported. Stopping monitor and disconnecting."), 
      this.close({
        allowReconnect: !1
      });
    },
    close: function(t) {
      if (o.log("WebSocket onclose event"), !this.disconnected) return this.disconnected = !0, 
      this.monitor.recordDisconnect(), this.subscriptions.notifyAll("disconnected", {
        willAttemptReconnect: this.monitor.isRunning()
      });
    },
    error: function() {
      o.log("WebSocket onerror event");
    }
  };
  var g = function(t, n) {
    if (null != n) for (var e in n) {
      var o = n[e];
      t[e] = o;
    }
    return t;
  }, m = function() {
    function t(n) {
      var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, o = arguments[2];
      r(this, t), this.consumer = n, this.identifier = JSON.stringify(e), g(this, o);
    }
    return t.prototype.perform = function(t) {
      var n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
      return n.action = t, this.send(n);
    }, t.prototype.send = function(t) {
      return this.consumer.send({
        command: "message",
        identifier: this.identifier,
        data: JSON.stringify(t)
      });
    }, t.prototype.unsubscribe = function() {
      return this.consumer.subscriptions.remove(this);
    }, t;
  }(), b = function() {
    function t(n) {
      r(this, t), this.consumer = n, this.subscriptions = [];
    }
    return t.prototype.create = function(t, n) {
      var e = t, o = "object" === (void 0 === e ? "undefined" : i(e)) ? e : {
        channel: e
      }, r = new m(this.consumer, o, n);
      return this.add(r);
    }, t.prototype.add = function(t) {
      return this.subscriptions.push(t), this.consumer.ensureActiveConnection(), this.notify(t, "initialized"), 
      this.sendCommand(t, "subscribe"), t;
    }, t.prototype.remove = function(t) {
      return this.forget(t), this.findAll(t.identifier).length || this.sendCommand(t, "unsubscribe"), 
      t;
    }, t.prototype.reject = function(t) {
      var n = this;
      return this.findAll(t).map(function(t) {
        return n.forget(t), n.notify(t, "rejected"), t;
      });
    }, t.prototype.forget = function(t) {
      return this.subscriptions = this.subscriptions.filter(function(n) {
        return n !== t;
      }), t;
    }, t.prototype.findAll = function(t) {
      return this.subscriptions.filter(function(n) {
        return n.identifier === t;
      });
    }, t.prototype.reload = function() {
      var t = this;
      return this.subscriptions.map(function(n) {
        return t.sendCommand(n, "subscribe");
      });
    }, t.prototype.notifyAll = function(t) {
      for (var n = this, e = arguments.length, o = Array(e > 1 ? e - 1 : 0), i = 1; i < e; i++) o[i - 1] = arguments[i];
      return this.subscriptions.map(function(e) {
        return n.notify.apply(n, [ e, t ].concat(o));
      });
    }, t.prototype.notify = function(t, n) {
      for (var e = arguments.length, o = Array(e > 2 ? e - 2 : 0), i = 2; i < e; i++) o[i - 2] = arguments[i];
      return ("string" == typeof t ? this.findAll(t) : [ t ]).map(function(t) {
        return "function" == typeof t[n] ? t[n].apply(t, o) : void 0;
      });
    }, t.prototype.sendCommand = function(t, n) {
      var e = t.identifier;
      return this.consumer.send({
        command: n,
        identifier: e
      });
    }, t;
  }(), v = function() {
    function t(n) {
      var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
      r(this, t), this._url = n, this.jwt_token = e, this.subscriptions = new b(this), 
      this.connection = new y(this);
    }
    return t.prototype.send = function(t) {
      return this.connection.send(t);
    }, t.prototype.connect = function() {
      return this.connection.open();
    }, t.prototype.disconnect = function() {
      return this.connection.close({
        allowReconnect: !1
      });
    }, t.prototype.ensureActiveConnection = function() {
      if (!this.connection.isActive()) return this.connection.open();
    }, s(t, [ {
      key: "url",
      get: function() {
        return S(this._url);
      }
    } ]), t;
  }();
  function S(t) {
    if ("function" == typeof t && (t = t()), t && !/^wss?:/i.test(t)) {
      var n = document.createElement("a");
      return n.href = t, n.href = n.href, n.protocol = n.protocol.replace("http", "ws"), 
      n.href;
    }
    return t;
  }
  function A(t) {
    var n = document.head.querySelector("meta[name='action-cable-" + t + "']");
    if (n) return n.getAttribute("content");
  }
  t.Connection = y, t.ConnectionMonitor = l, t.Consumer = v, t.INTERNAL = p, t.Subscription = m, 
  t.Subscriptions = b, t.adapters = e, t.createWebSocketURL = S, t.logger = o, t.createConsumer = function() {
    var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : A("url") || p.default_mount_path, n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
    return new v(t, n);
  }, t.getConfig = A, Object.defineProperty(t, "__esModule", {
    value: !0
  });
});
